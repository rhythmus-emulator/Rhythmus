#pragma once

#include "Font.h"
#include "Util.h"

RHYTHMUS_NAMESPACE_BEGIN

/**
 * text alignment option
 * 0 : normal
 * 1 : left
 * 2 : right
 * 3 : offset -50% of text width
 * 4 : offset -100% of text width
 * (LR2 legacy option)
 */
enum TextAlignments
{
  kTextAlignLeft,
  kTextAlignRight,
  kTextAlignCenter,
  kTextAlignLR2Right,
  kTextAlignLR2Center,
};

/**
 * Text fitting option
 * LR2 uses Stretch to maxsize generally.
 */
enum TextFitting
{
  kTextFitNone,
  kTextFitMaxSize,
  kTextFitStretch,
};

class Text : public BaseObject
{
public:
  Text();
  virtual ~Text();

  void SetFontByPath(const std::string& path);
  void SetSystemFont();

  float GetTextWidth() const;
  virtual void SetText(const std::string& s);
  virtual void Refresh();
  void SetTextAlignment(TextAlignments align);
  void SetTextFitting(TextFitting fitting);
  void SetLineBreaking(bool enable_line_break);
  void Clear();

  Font *font();

  virtual void Load(const Metric& metric);
  virtual void LoadFromLR2SRC(const std::string &cmd);

protected:
  void SetFont(Font *font);
  virtual void SetLR2Alignment(int alignment);
  virtual void doRender();
  virtual void doUpdate(float);
  void UpdateTextRenderContext();
  void ClearTextVertex();
  TextVertexInfo& AddTextVertex(const TextVertexInfo &tvi);
  void SetTextVertexCycle(size_t cycle, size_t duration);
  void SetWidthMultiply(float multiply); /* special API for LR2 */

private:
  // Font.
  Font *font_;

  // text to be rendered
  std::string text_;

  // text_rendering related context
  struct {
    // glyph vertex to be rendered (generated by textglyph)
    std::vector<TextVertexInfo> textvertex;

    // calculated text width / height
    float width, height;

    // cycle attributes (optional)
    // if cycle exists, textvertex must be multiply of cycle.
    size_t cycles, duration, time;
  } text_render_ctx_;

  TextAlignments text_alignment_;
  TextFitting text_fitting_;

  // additional font attributes, which is set internally by font_alignment_ option.
  struct {
    // scale x / y
    float sx, sy;
    // translation x / y
    float tx, ty;
  } alignment_attrs_;

  float width_multiply_;

  // is line-breaking enabled?
  bool do_line_breaking_;

  virtual void SetLR2DSTCommandInternal(const CommandArgs &args);
};

RHYTHMUS_NAMESPACE_END