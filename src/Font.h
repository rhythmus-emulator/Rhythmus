#pragma once

#include "Sprite.h"
#include <stdint.h>
#include <string>
#include <vector>

namespace rhythmus
{

struct FontAttributes
{
  int size;
};

struct FontGlyph
{
  uint32_t codepoint;
  int width, height;
  int texidx, srcx, srcy;
  float sx1, sy1, sx2, sy2;
};

class FontBitmap
{
public:
  FontBitmap(int w, int h);
  ~FontBitmap();
  void Write(uint32_t* bitmap, int w, int h, FontGlyph &glyph_out);
  void Update();
  bool IsWritable(int w, int h) const;
  GLuint get_texid() const;

private:
  uint32_t* bitmap_;
  GLuint texid_;
  int width_, height_;
  int cur_line_height_;
  int cur_x_, cur_y_;
  bool committed_;

  void GetGlyphTexturePos(FontGlyph &glyph_out);
};

class Font : public Sprite
{
public:
  Font();
  ~Font();

  bool LoadFont(const char* ttfpath, FontAttributes& attrs);
  bool LoadLR2Font(const char* lr2fontpath);
  void PrepareGlyph(uint32_t *chrs, int count);
  void Commit();

  const FontGlyph* GetGlyph(uint32_t chr) const;
  bool IsNullGlyph(const FontGlyph* g) const;
  void SetNullGlyphAsCodePoint(uint32_t chr);
  float GetTextWidth(const std::string& s);
  void SetText(const std::string& s);

  void ClearGlyph();
  void ReleaseFont();

  virtual void Render();

private:
  // FT_Face type
  void *ftface_;

  // cached glyph
  std::vector<FontGlyph> glyph_;

  // store bitmap / texture
  std::vector<FontBitmap*> fontbitmap_;
  int bitmap_cache_width, bitmap_cache_height;

  // current font attributes
  FontAttributes fontattr_;

  // text to be rendered
  std::string text_;

  // glyphs prepared to be rendered (generated by text)
  std::vector<const FontGlyph*> textglyph_;

  // glyph which is returned when glyph is not found
  FontGlyph null_glyph_;

  void ConvertStringToCodepoint(const std::string& s, uint32_t *cp, int& lenout, int maxlen = -1);
  FontBitmap* GetWritableBitmapCache(int w, int h);
};

}